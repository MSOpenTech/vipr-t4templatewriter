<# InitFields((CustomT4Host) Host); #>
<#=writer.WriteHeader()#>

<#+

private CustomT4Host host;
private OdcmModel model;
private CodeWriterObjC writer;
private String prefix;
private OdcmClass entity;

private void InitFields(CustomT4Host Host)
{
    host = Host;
    model = host.CurrentModel;
    writer = (CodeWriterObjC) host.CodeWriter;
    prefix = writer.GetPrefix();
    entity = host.CurrentType.AsOdcmClass();
    
    ObjCStringExtensions.EntityContainerName = (model.EntityContainer==null ? "" : model.EntityContainer.Name);
}

private void GenerateHeaderGuards(string fileName)
{
    
#>
#ifndef <#=fileName.ToUpper()#>_H
#define <#=fileName.ToUpper()#>_H
<#+
}

private void GenerateInterfacePrologue(OdcmClass e)
{
    string baseEntityName = e.Base == null ? "MSOrcBaseEntity" : e.Base.ToObjCInterface();
    
#>
#import "<#=e.Base == null ? "core/MSOrcBaseEntity" : e.Base.ToObjCInterface()#>.h"
#import "api/MSOrcInteroperableWithDictionary.h"

/** Interface <#= e.ToObjCInterface() #>
 *
 */
@interface <#=e.ToObjCInterface()#> : <#=baseEntityName#> <MSOrcInteroperableWithDictionary>

<#+
}

private void GenerateImplementationPrologue(OdcmClass e,string suffix="")
{
    string iName=e.GetRelatedEntityTypeString(suffix);
#>

/** Implementation for <#=iName  #>
 *
 */
@implementation <#=iName #>

<#+
}

private void GenerateMethodParameters(OdcmMethod method, string typeOverride=null)
{
    int i=0;
    foreach (var p in method.Parameters) 
    {
        string parameterName=p.Name.ToObjCMethodSignatureParameter(method.Name,i);
        string typeString= (typeOverride!=null && typeOverride!="")?typeOverride:
                            p.Type.GetTypeReferenceString();
        #><#=parameterName#>:(<#=typeString#>)<#=p.Name.ToObjCMethodParameter()#> <#+
        i++;
    }
}

private void GenerateCallbackParameter(string typeStr,bool firstParameter=false)
{
    #><#=firstParameter?"WithC":"c"#>allback:(void (^)(<#=typeStr#>, MSOrcError*))callback <#+
}

private void GenerateCallbackParameter(OdcmType type,bool firstParameter=false)
{
    GenerateCallbackParameter(type.GetTypeReferenceString(),firstParameter);
}

private void GenerateSetterImplementationsForProperties(OdcmClass entity)
{
    foreach(var prop in entity.Properties)
    {
#>
/** Setter implementation for property <#= prop.Name.ToObjCProperty() #>
 *
 */
- (void) <#=prop.GetSetterString()#>: (<#=prop.GetTypeReferenceString()#>) value {
    _<#=prop.Name.ToObjCProperty()#> = value;
    [self valueChangedFor:@"<#=prop.Name#>"];
}
       
<#+    

        if(prop.IsEnum())
        {
#>

- (void)<#=prop.GetSetterString()#>String:(NSString *)string {
        
    _<#=prop.Name.ToObjCProperty()#> = [<#=prop.GetTypeReferenceString()#>Serializer fromString:string];
    [self valueChangedFor:@"<#=prop.Name#>"]; 
}

<#+         
        }


    } 
}

HashSet<string> GetUniqueStrings<T>(IEnumerable<T> elements, HashSet<T> exclusions, Func<T,string> stringGen )
{
    HashSet<string> uniqueStrings = new HashSet<string>();   
    
    foreach(var element in elements)
    {
        if(exclusions!=null && exclusions.Contains(element)) continue;
        string uString=stringGen(element);
        if(uString!=null) uniqueStrings.Add(uString);
    }
    
    return uniqueStrings;
}

void OutputUniqueStrings<T>(IEnumerable<T> elements, HashSet<T> exclusions, Func<T,string> stringGen, Func<string,string> stringOut )
{
    foreach(var uString in GetUniqueStrings(elements,exclusions,stringGen))
    {
        string transformedUString=stringOut(uString);
        if(transformedUString!=null) Write(transformedUString);
    }
}


private void GenerateClassForwardDeclarations(OdcmClass entity)
{
    GenerateClassForwardDeclarations(entity.Properties,entity);
}

private void GenerateClassForwardDeclarationsForFetcher(OdcmClass entity)
{
    GenerateClassForwardDeclarations(entity.Properties,entity,true);
}

private void GenerateClassForwardDeclarationsForFetcherDerived(OdcmClass entity)
{
    foreach(var child in entity.Derived)
    {
#>
@class <#=child.GetRelatedEntityTypeString("Fetcher")#>;	
<#+
    }
}


private void GenerateClassForwardDeclarationsForFetcherNavProps(OdcmClass entity)
{
    GenerateClassForwardDeclarations(entity.NavigationProperties(),entity,true);
    
    OutputUniqueStrings(entity.NavigationProperties(),null,
    prop =>
    {
        if(prop.IsCollection() && prop.Type.IsFromOurNamespace())
        {
            return prop.Type.GetRelatedEntityTypeString("Fetcher");
        }
        return null;
    },
    stringIn =>
    {
        return "@class " + stringIn + ";\n";
    });
}


private void GenerateClassForwardDeclarations(IEnumerable<OdcmProperty> Properties, OdcmType exclusion=null, bool forFetcher=false)
{
    OutputUniqueStrings(Properties,null,
        prop =>
        {
            if(prop.Type!=exclusion && prop.Type.IsFromOurNamespace() && prop.Type.IsComplex())
            {                
                if(forFetcher)
                {
                    return prop.Type.GetRelatedEntityTypeString(prop.IsCollection()?"CollectionFetcher":"Fetcher");
                }
                else return prop.Type.GetTypeString();
                                
            }
            return null;
        },
        stringIn =>
        {
            return "@class " + stringIn + ";\n";
        });
}

private void GenerateImportsForEnums(OdcmClass entity)
{
    GenerateImportsForEnums(entity.Properties);
}

private void GenerateImportsForEnums(IEnumerable<OdcmProperty> Properties)
{
    OutputUniqueStrings(Properties,null,
        prop =>
        {
            if(prop.IsEnum() && prop.Type.IsFromOurNamespace())
            {
                return prop.Type.GetTypeString();
            }
            return null;
        },
        stringIn =>
        {
            return "#import \"" + stringIn + ".h\"\n";
        });
}

private void GenerateActionMethodSignature(OdcmMethod action)
{
#>- (void)<#=action.GetMethodString() #><#+GenerateMethodParameters(action);#><#+GenerateCallbackParameter(action.ReturnType,action.Parameters.Count==0);#><#+   
}

private void GenerateActionMethodRawSignature(OdcmMethod action)
{
#>- (void)<#=action.GetMethodString() #>Raw<#+GenerateMethodParameters(action,"NSString *");#><#+GenerateCallbackParameter("NSString *",action.Parameters.Count==0);#><#+	
}

private void GenerateActionMethodRawCallPrologue(OdcmMethod method)
{
#><#=method.GetMethodString() #>Raw<#+
   
    int i=0;
    foreach (var p in method.Parameters) 
    {
        string parameterName=p.Name.ToObjCMethodSignatureParameter(method.Name,i);
        #><#=parameterName#>:<#=p.Name.ToObjCMethodParameter()#>String <#+
        i++;
    }
#><#="callback".ToObjCMethodSignatureParameter(method.Name,i)#><#+
}


private void GenerateActionMethodDeclarations(OdcmClass entity)
{

    foreach(var action in entity.Actions())
    {
        if(!action.IsBoundToCollection)
        {

            GenerateActionMethodSignature(action);#>;
<#+
            if(!action.IsFunction())
            {
                GenerateActionMethodRawSignature(action);#>;
<#+
            }
        }
    }

  
}

public void GenerateDictionaryFromParameters(string dicName, List<OdcmParameter> parameters,bool toArray=false,bool paramsAreString=false)
{
    if(!parameters.Any())
    {
        
        if(toArray)
        {
#>
NSArray *<#=dicName#> = [[NSArray alloc] init];
<#+            
        }
        else
        {
#>
NSDictionary *<#=dicName#> = [[NSDictionary alloc] init];
<#+            
        }
        
    }
    else
    {

        if(toArray)
        {
#>
NSArray *<#=dicName#> = [[NSArray alloc] initWithObjects: [[NSDictionary alloc] initWithObjectsAndKeys: <#+
            
        }
        else
        {
#>
NSDictionary *<#=dicName#> = [[NSDictionary alloc] initWithObjectsAndKeys: <#+
          
        }
        

        foreach (var param in parameters)
        {
            if(paramsAreString)
            {
#> <#=param.Name.ToObjCMethodParameter()#>,<#+                
            }
            else if(param.GetTypeString() == "bool")
            {
#> <#=param.Name.ToObjCMethodParameter()#>?@"true":@"false",<#+                
            }
            else if(param.GetTypeString() == "int")
            {
#> <#=writer.NewStringFromIntegerVariable(param.Name.ToObjCMethodParameter())#>,<#+                
            }
            else
            {
#> <#=param.Name.ToObjCMethodParameter()#>,<#+
            }
#> @"<#=param.Name#>",<#+
        }
    
#> nil ] <#=toArray?", nil]":""#>;
<#+
    }
    
}

public List<OdcmProperty> GetPropertiesFromWholeHierarchy(OdcmClass entity)
{
    List<OdcmProperty> properties = new List<OdcmProperty>();
    
    do
    {
        foreach (var prop in entity.Properties)
        {
            properties.Add(prop);
        }
        
    }while((entity=entity.Base)!=null);
    
    return properties;
}



public void SetPropertiesNamesMappings(OdcmClass entity)
{
    var properties = GetPropertiesFromWholeHierarchy(entity);
    if(properties.Count>0)
    {
    #>
    if(_$$$_$$$propertiesNamesMappings==nil) {
    
        _$$$_$$$propertiesNamesMappings=[[NSDictionary alloc] initWithObjectsAndKeys: <#+
       
        foreach (var prop in properties)
        {
        #> @"<#=prop.Name #>", @"<#=prop.Name.ToObjCProperty() #>",<#+
        }  

        #> nil];
        
    }
<#+
    }
}

public void GenerateStringsFromParameters(List<OdcmParameter> parameters)
{
    foreach (var param in parameters)
    {
#>  NSString *<#=param.Name.ToObjCMethodParameter()#>String = <#=GenerateStringFromORCValue(param.Type,param.Name.ToObjCMethodParameter())#>;

<#+
    }
    
}

public void GenerateJsonPayloadFromStringParameters(List<OdcmParameter> parameters)
{
    
    GenerateDictionaryFromParameters("parameters",parameters,true,true);

#>
    NSData* payload = [[MSOrcBaseContainer generatePayloadWithParameters:parameters dependencyResolver:self.resolver] dataUsingEncoding:NSUTF8StringEncoding];
    [request setContent:payload];
<#+
}


private void GenerateActionMethodImplementation(OdcmMethod action)
{
    
    GenerateActionMethodSignature(action);#>{

<#+ if (action.IsFunction()) { #>

	id<MSOrcRequest> request = [self.resolver createOrcRequest];
	<#+GenerateDictionaryFromParameters("params",action.Parameters);#>
	
	NSString *parameters = [MSOrcBaseContainer getFunctionParameters:params];

	[request.url appendPathComponent:[[NSString alloc] initWithFormat:@"<#=action.Name#>(%@)",parameters]];
	[request setVerb:HTTP_VERB_POST];

	return [super orcExecuteRequest:request callback:^(id<MSOrcResponse> response, MSOrcError *e) {
       
        if (e == nil) {
            <#=action.ReturnType.GetTypeReferenceString()#> result = (<#=action.ReturnType.GetTypeReferenceString()#>)<#=GenerateORCValueFromString(action.ReturnType,"[[NSString alloc] initWithData:response.data encoding:NSUTF8StringEncoding]")#>;
            callback(result, e);
        }
        else {

            callback(<#=action.ReturnType.IsComplex() ? "nil" : " response.status"#>, e);
        }
        
    }];
    
<#+ }else{ #>

    <#+GenerateStringsFromParameters(action.Parameters);#>
    return [self <#+ GenerateActionMethodRawCallPrologue(action);#>:^(NSString *returnValue, MSOrcError *e) {
       
       if (e == nil) {
            <#=action.ReturnType.GetTypeReferenceString()#> result = (<#=action.ReturnType.GetTypeReferenceString()#>)<#=GenerateORCValueFromString(action.ReturnType,"returnValue")#>;
            callback(result, e);
        } 
        else {

            callback(<#=action.ReturnType.IsComplex() ? "nil" : "(int)[returnValue integerValue]"#>, e);
        }
    }];    
    
<#+ } #>
        
}

<#+
}

private void GenerateActionMethodRawImplementation(OdcmMethod action)
{
    GenerateActionMethodRawSignature(action);#>{
        
    id<MSOrcRequest> request = [super.resolver createOrcRequest];
    
    <#+
    
    if(action.Parameters.Any())
    {
        GenerateJsonPayloadFromStringParameters(action.Parameters);
    }
    
    #>
    
    [request setVerb:HTTP_VERB_POST];
	 <#+ if (ConfigurationService.Settings.AllowShortActions) { #>    
	[request.url appendPathComponent:@"<#= action.Name#>"];
        <#+ } else { #>
	[request.url appendPathComponent:@"<#= action.FullName#>"];
     <#+}#>
	
    return [super orcExecuteRequest:request callback:^(id<MSOrcResponse> response, MSOrcError *e) {
        
		if (e == nil) {
            
			callback([[NSString alloc] initWithData:response.data encoding:NSUTF8StringEncoding], e);
        }
        else {

            callback([[NSString alloc] initWithFormat:@"%d", response.status], e);
        }
    }];
    
    }
<#+
}


private void GenerateActionMethodImplementations(OdcmClass entity)
{
    foreach(var action in entity.Actions())
    {
        if(!action.IsBoundToCollection)
        {
            GenerateActionMethodImplementation(action);
            if(!action.IsFunction())
            {
                GenerateActionMethodRawImplementation(action);
            }
        }
    }
}


private void GeneratePropertyDeclaration(OdcmProperty prop)
{
#>
/** Property <#= prop.Name.ToObjCProperty() #>
 *
 */
@property (nonatomic, <#=prop.IsComplex()?" copy,":""#> setter=<#=prop.GetSetterString()#>:, getter=<#=prop.GetGetterString()#>) <#=prop.GetTypeReferenceString()#> <#=prop.Name.ToObjCProperty()#>;

<#+    

    if(prop.IsEnum())
    {
#>
- (void)<#=prop.GetSetterString()#>String:(NSString *)string;

<#+         
    }

}

private string GenerateORCValueFromString(OdcmType type,string valueName)
{

    if(type.IsPODType())
    {
        string podPrologue = "[MSOrcObjectizer ";
        switch(type.GetTypeString())
        {
            case "int":         return podPrologue + "intFromString:" + valueName + "]";
            case "float":       return podPrologue + "floatFromString:" + valueName + "]";
            case "double":      return podPrologue + "doubleFromString:" + valueName + "]";
            case "bool":        return podPrologue + "boolFromString:" + valueName + "]";
            case "long long":   return podPrologue + "longLongFromString:" + valueName + "]";
            default: return podPrologue + "intFromString:" + valueName + "]";
        }
    }
    else if(type.IsEnum())
    {
        return "[" + type.GetTypeString() + "Serializer fromString:" + valueName + "]";
    }
    else if(type.GetTypeString() == "NSString")
    {
        return "[" + valueName + " copy]";
    }
    else if(type.GetTypeString() == "NSDate")
    {
        return "[MSOrcObjectizer dateFromString:" + valueName + "]";
    }
    else if(type.GetTypeString() == "NSTimeInterval")
    {
        return "[MSOrcObjectizer timeIntervalFromString:" + valueName + "]";
    }
    else if(type.GetTypeString() == "NSData")
    {
        return "[MSOrcObjectizer dataFromString:" + valueName + "]";
    }
    else if(type.GetTypeString() == "NSStream")
    {
        return "nil/*NSStream*/";
    }
    else 
    {
        return "[MSOrcObjectizer objectizeFromString:" + valueName + " toType: [" + type.GetTypeString() + "  class]]";  
    }
    
    return "nil/*Unhandled Type*/";    
}

private string GenerateStringFromORCValue(OdcmType type, string valueName)
{
    if(type.IsPODType())
    {
        string podPrologue = "[MSOrcObjectizer ";
        switch(type.GetTypeString())
        {
            case "int":         return podPrologue + "stringFromInt:" + valueName + "]";
            case "float":       return podPrologue + "stringFromFloat:" + valueName + "]";
            case "double":      return podPrologue + "stringFromDouble:" + valueName + "]";
            case "bool":        return podPrologue + "stringFromBool:" + valueName + "]";
            case "long long":   return podPrologue + "stringFromLongLong:" + valueName + "]";
            default: return podPrologue + "stringFromInt:" + valueName + "]";
        }
    }
    else if(type.IsEnum())
    {
        return "[" + type.GetTypeString() + "Serializer toString:" + valueName + "]";
    }
    else if(type.GetTypeString() == "NSString")
    {
        return "[NSString stringWithFormat:@\"\\\"%@\\\"\", " + valueName + "]";
    }
    else if(type.GetTypeString() == "NSDate")
    {
        return "[MSOrcObjectizer stringFromDate:" + valueName + "]";
    }
    else if(type.GetTypeString() == "NSTimeInterval")
    {
        return "[MSOrcObjectizer stringFromTimeInterval:" + valueName + "]";
    }
    else if(type.GetTypeString() == "NSData")
    {
        return "[MSOrcObjectizer stringFromData:" + valueName + "]";
    }
    else if(type.GetTypeString() == "NSStream")
    {
        return "nil/*NSStream*/";
    }
    else 
    {
        return "[MSOrcObjectizer deobjectizeToString:" + valueName + "]";   
    }
}



///////////////////////////////////////

private string GenerateORCValueFromDictionaryValue(OdcmProperty prop , string obj)
{
    if(prop.IsPODType(true))
    {
        string podPrologue = "[" + obj + " ";
        switch(prop.GetTypeString(true))
        {
            case "int":         return podPrologue + "intValue]";
            case "float":       return podPrologue + "floatValue]";
            case "double":      return podPrologue + "doubleValue]";
            case "bool":        return podPrologue + "boolValue]";
            case "long long":   return podPrologue + "longLongValue]";
            default: return podPrologue + "intValue]";
        }
    }
    else if(prop.IsEnum(true))
    {
        return "[" + prop.GetTypeString(true) + "Serializer fromString:" + obj + "]";
    }
    else if(prop.GetTypeString(true) == "NSString")
    {
        return "[" + obj + " copy]";
    }
    else if(prop.GetTypeString(true) == "NSDate")
    {
        return "[MSOrcObjectizer dateFromString:" + obj + "]";
    }
    else if(prop.GetTypeString(true) == "NSTimeInterval")
    {
        return "[MSOrcObjectizer timeIntervalFromString:" + obj + "]";
    }
    else if(prop.GetTypeString(true) == "NSData")
    {
        return "[MSOrcObjectizer dataFromString:" + obj + "]";
    }
    else if(prop.GetTypeString(true) == "NSStream")
    {
        return "nil/*NSStream*/";
    }
    else 
    {
        return "[[" + prop.GetTypeString(true) + " alloc] initWithDictionary: " + obj + "]";   
    }
    
    return "nil/*Unhandled Type*/";
}


private string GenerateDictionaryValueFromORCValue(OdcmProperty prop)
{
    OdcmType type=prop.Type;
    string valueName="self." + prop.Name.ToObjCProperty();
    return GenerateDictionaryValueFromORCValue(type,valueName);
}

private string GenerateDictionaryValueFromORCValue(OdcmType type, string valueName)
{
    if(type.IsPODType())
    {
        if(type.GetTypeString()=="bool")
        {
            return "(" + valueName + "?@\"true\":@\"false\")";
        }
        
        string podStr = "[NSNumber ";
        switch(type.GetTypeString())
        {
            case "int":         podStr+="numberWithInt: "; break;
            case "float":       podStr+="numberWithFloat: "; break;
            case "double":      podStr+="numberWithDouble: "; break;
            case "long long":   podStr+="numberWithLongLong: "; break;
            default:            podStr+="numberWithInt: "; break;
        }
        podStr += valueName + "]";
        return podStr;
    }
    else if(type.IsEnum())
    {
        return "[" + type.GetTypeString() + "Serializer toString:" + valueName + "]";
    }
    else if(type.GetTypeString() == "NSString")
    {
        return "[" + valueName + " copy]";
    }
    else if(type.GetTypeString() == "NSDate")
    {
        return "[MSOrcObjectizer stringFromDate:" + valueName + "]";
    }
    else if(type.GetTypeString() == "NSTimeInterval")
    {
        return "[MSOrcObjectizer stringFromTimeInterval:" + valueName + "]";
    }
    else if(type.GetTypeString() == "NSData")
    {
        return "[MSOrcObjectizer stringFromData:" + valueName + "]";
    }
    else if(type.GetTypeString() == "NSStream")
    {
        return "nil/*NSStream*/";
    }
    else 
    {
        return "[" + valueName + " toDictionary]";   
    }

    return "nil/*Unhandled Type*/";
}


private void GenerateArrayToDictionaryEntry(OdcmType arrayType, string arrayName,string currentArray)
{
    #>
    NSMutableArray *<#=arrayName#> = [[NSMutableArray alloc] init];
    
    for(id obj in <#=currentArray#>) {
       [<#=arrayName#> addObject:<#=GenerateDictionaryValueFromORCValue(arrayType,"obj")#>];
    }
    
    <#+
}

private void GenerateImplementationsForMSOrcInteroperableWithDictionary(OdcmClass entity)
{
#>

- (instancetype) initWithDictionary: (NSDictionary *) dic {
    if((self = [self init])) {
        if(dic!=nil) {
<#+
    foreach (var prop in GetPropertiesFromWholeHierarchy(entity))
    {
        string dictionaryAccess = "[dic objectForKey: @\"" + prop.Name + "\"]";
        string curPropAccess=(entity.Properties.Contains(prop)?"_":"self.")+prop.Name.ToObjCProperty();
        
        if(prop.IsCollection)
        {
            
#>

        if(<#=dictionaryAccess#> != [NSNull null]){
            <#=curPropAccess#> = [[MSOrcChangesTrackingArray alloc] init];
            
            for (id object in <#=dictionaryAccess#>) {
                [<#=curPropAccess#> addObject:<#=(prop.IsPODType() || prop.IsEnum(true))?
                "@("+GenerateORCValueFromDictionaryValue(prop,"object") + ")":
                     GenerateORCValueFromDictionaryValue(prop,"object")#>];
            }
            
            [(MSOrcChangesTrackingArray *)<#=curPropAccess#> resetChangedFlag];
        }
        
<#+

        }
        else
        {
            this.Write("\t\t" + curPropAccess + " = (!" + dictionaryAccess + " || [ " + dictionaryAccess + " isKindOfClass:[NSNull class]] )?" + curPropAccess + ":" + GenerateORCValueFromDictionaryValue(prop,dictionaryAccess) + ";\n");
        }
    }
    #>
    }
    [self.updatedValues removeAllObjects];
    }
    
    return self;
}

- (NSDictionary *) toDictionary {
    
    NSMutableDictionary *dic=[[NSMutableDictionary alloc] init];

<#+
   
    foreach (var prop in GetPropertiesFromWholeHierarchy(entity))
    {        
        this.Write("\t{");
        
        if(prop.IsCollection)
        {
            GenerateArrayToDictionaryEntry(prop.Type,"curVal","self." + prop.Name.ToObjCProperty());
            this.Write("if([curVal count]==0) curVal=nil;\n");
            this.Write("if (curVal!=nil) [dic setValue: curVal");
            this.Write(" forKey: @\"" + prop.Name + "\"];}\n");
        }
        else
        {
            if(prop.IsComplex())
            {
                this.Write("id curVal = " + GenerateDictionaryValueFromORCValue(prop) + ";");
                this.Write("if (curVal!=nil) [dic setValue: curVal");
                this.Write(" forKey: @\"" + prop.Name + "\"];}\n");
            }
            else
            {
                this.Write("[dic setValue: " + GenerateDictionaryValueFromORCValue(prop) + " forKey: @\"" + prop.Name + "\"];}\n");
            }
        }
        
        
    }
#>
    [dic setValue: @"#<#=model.GetNamespace()#>.<#=entity.Name#>" forKey: @"@odata.type"];

    return dic;
}

- (NSDictionary *) toUpdatedValuesDictionary {
    
    NSMutableDictionary *dic=[[NSMutableDictionary alloc] init];

<#+
   
    foreach (var prop in GetPropertiesFromWholeHierarchy(entity))
    {        
        if(prop.IsComplex())
        {
        this.Write("\t{id curVal = " + "self." + prop.Name.ToObjCProperty() + ";" );
        #>

    if([self.updatedValues containsObject:@"<#=prop.Name#>"])
    {
        <#+
        if(prop.IsCollection())
        {
        //Collection update:
        GenerateArrayToDictionaryEntry(prop.Type,"curArray","curVal");
        #>
        [dic setValue: curArray forKey: @"<#=prop.Name#>"];
        <#+
        }
        else
        {
        //Complex update 
        #>
        [dic setValue: curVal==nil?[NSNull null]:<#=GenerateDictionaryValueFromORCValue(prop.Type,"curVal")#> forKey: @"<#=prop.Name#>"];
        <#+
        }
        #>
    }
    <#+
        if(prop.IsCollection() || prop.Type.IsFromOurNamespace())
        {
    #>
    else
    {
        <#+
        if(prop.IsCollection())
        {
        //Check collection change:
        #>
        
        if(![curVal isKindOfClass:[MSOrcChangesTrackingArray class]] || [(MSOrcChangesTrackingArray *)curVal hasChanged])
        {
            <#+GenerateArrayToDictionaryEntry(prop.Type,"curArray","self." + prop.Name.ToObjCProperty());#>
             [dic setValue: curArray forKey: @"<#=prop.Name#>"];
        }
        
        <#+
        }
        else
        {
        //Check complex change    
        #>
        
        NSDictionary *updatedDic=[curVal toUpdatedValuesDictionary];
        
            if(updatedDic!=nil && [updatedDic count]>0)
            {
                [dic setValue: [curVal toDictionary] forKey: @"<#=prop.Name#>"];
            }
        
        <#+
        }
        #>
    }<#+
        }
    #>
}
<#+
        }
        else
        {
           #> if([self.updatedValues containsObject:@"<#=prop.Name#>"])
            { <#+
                this.Write("[dic setValue: " + GenerateDictionaryValueFromORCValue(prop) + " forKey: @\"" + prop.Name + "\"];\n");
           #>}<#+
        }
    }
#>
    return dic;
}

<#+
}

#>
